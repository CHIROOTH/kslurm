from __future__ import absolute_import, annotations

from typing import Iterable, Literal, Optional, OrderedDict, SupportsInt, Tuple, Union

class VersionInfo:
    def __init__(
        self,
        major: SupportsInt,
        minor: SupportsInt = ...,
        patch: SupportsInt = ...,
        prerelease: Union[str, bytes, int, None] = ...,
        build: Union[str, bytes, int, None] = ...,
    ) -> None: ...

    def __eq__(self, other: object) -> bool: ...

    def __ge__(self, other: object) -> bool: ...

    def __getitem__(
        self, index: Union[int, slice]
    ) -> Union[int, str, None, Tuple[Union[int, str], ...]]: ...

    def __gt__(self, other: object) -> bool: ...

    def __hash__(self) -> int: ...

    def __iter__(self) -> Iterable[Union[int, str, None]]: ...

    def __le__(self, other: object) -> bool: ...

    def __lt__(self, other: object) -> bool: ...

    def __ne__(self, other: object) -> bool: ...

    def __repr__(self) -> str: ...

    def __str__(self) -> str: ...

    @property
    def major(self) -> int: ...

    @property
    def minor(self) -> int: ...

    @property
    def patch(self) -> int: ...

    @property
    def prerelease(self) -> Optional[str]: ...

    @property
    def build(self) -> Optional[str]: ...

    def bump_major(self) -> "VersionInfo": ...

    def bump_minor(self) -> "VersionInfo": ...

    def bump_patch(self) -> "VersionInfo": ...

    def bump_prerelease(self, token: str = ...) -> "VersionInfo": ...

    def compare(self, other: "VersionInfo") -> int: ...

    def finalize_version(self) -> "VersionInfo": ...

    def match(self, match_expr: str) -> bool: ...

    def next_version(
        self,
        part: Union[
            Literal["major"], Literal["minor"], Literal["patch"], Literal["prerelease"]
        ],
        prerelease_token: str = ...,
    ) -> "VersionInfo": ...

    def replace(
        self,
        *,
        major: Optional[Union[int, str, None]] = ...,
        minor: Optional[Union[int, str, None]] = ...,
        patch: Optional[Union[int, str, None]] = ...,
        prerelease: Optional[Union[int, str, None]] = ...,
        build: Optional[Union[int, str, None]] = ...,
    ) -> "VersionInfo": ...

    def to_dict(self) -> OrderedDict[str, Union[int, str, None]]: ...

    def to_tuple(self) -> Tuple[int, int, int, Optional[str], Optional[str]]: ...

    @classmethod
    def parse(cls, version: Union[str, bytes]) -> "VersionInfo": ...

    @classmethod
    def isvalid(cls, version: str) -> bool: ...
